import{N as c,w as D,p as B,R as k,S as T,C as P,d as p,E as I,g as y,W as b,f as m,B as A,h,j as w,A as M,k as F,l as L,m as U,o as W,q as _,s as x,t as G}from"./index-DOXrWuLe.js";const g={getGasPriceInEther(o,n){const t=n*o;return Number(t)/1e18},getGasPriceInUSD(o,n,t){const r=g.getGasPriceInEther(n,t);return c.bigNumber(o).times(r).toNumber()},getPriceImpact({sourceTokenAmount:o,sourceTokenPriceInUSD:n,toTokenPriceInUSD:t,toTokenAmount:r}){const i=c.bigNumber(o).times(n),a=c.bigNumber(r).times(t);return i.minus(a).div(i).times(100).toNumber()},getMaxSlippage(o,n){const t=c.bigNumber(o).div(100);return c.multiply(n,t).toNumber()},getProviderFee(o,n=.0085){return c.bigNumber(o).times(n).toString()},isInsufficientNetworkTokenForGas(o,n){const t=n||"0";return c.bigNumber(o).eq(0)?!0:c.bigNumber(c.bigNumber(t)).gt(o)},isInsufficientSourceTokenForSwap(o,n,t){const r=t?.find(a=>a.address===n)?.quantity?.numeric;return c.bigNumber(r||"0").lt(o)}},E=15e4,O=6,d={initializing:!1,initialized:!1,loadingPrices:!1,loadingQuote:!1,loadingApprovalTransaction:!1,loadingBuildTransaction:!1,loadingTransaction:!1,fetchError:!1,approvalTransaction:void 0,swapTransaction:void 0,transactionError:void 0,sourceToken:void 0,sourceTokenAmount:"",sourceTokenPriceInUSD:0,toToken:void 0,toTokenAmount:"",toTokenPriceInUSD:0,networkPrice:"0",networkBalanceInUSD:"0",networkTokenSymbol:"",inputError:void 0,slippage:U.CONVERT_SLIPPAGE_TOLERANCE,tokens:void 0,popularTokens:void 0,suggestedTokens:void 0,foundTokens:void 0,myTokensWithBalance:void 0,tokensPriceMap:{},gasFee:"0",gasPriceInUSD:0,priceImpact:void 0,maxSlippage:void 0,providerFee:void 0},e=B({...d}),S={state:e,subscribe(o){return G(e,()=>o(e))},subscribeKey(o,n){return x(e,o,n)},getParams(){const o=m.state.activeCaipAddress,n=h.getPlainAddress(o),t=W(),r=_.getConnectorId(m.state.activeChain);if(!n)throw new Error("No address found to swap the tokens from.");const i=!e.toToken?.address||!e.toToken?.decimals,a=!e.sourceToken?.address||!e.sourceToken?.decimals||!c.bigNumber(e.sourceTokenAmount).gt(0),u=!e.sourceTokenAmount;return{networkAddress:t,fromAddress:n,fromCaipAddress:o,sourceTokenAddress:e.sourceToken?.address,toTokenAddress:e.toToken?.address,toTokenAmount:e.toTokenAmount,toTokenDecimals:e.toToken?.decimals,sourceTokenAmount:e.sourceTokenAmount,sourceTokenDecimals:e.sourceToken?.decimals,invalidToToken:i,invalidSourceToken:a,invalidSourceTokenAmount:u,availableToSwap:o&&!i&&!a&&!u,isAuthConnector:r===p.CONNECTOR_ID.AUTH}},setSourceToken(o){if(!o){e.sourceToken=o,e.sourceTokenAmount="",e.sourceTokenPriceInUSD=0;return}e.sourceToken=o,s.setTokenPrice(o.address,"sourceToken")},setSourceTokenAmount(o){e.sourceTokenAmount=o},setToToken(o){if(!o){e.toToken=o,e.toTokenAmount="",e.toTokenPriceInUSD=0;return}e.toToken=o,s.setTokenPrice(o.address,"toToken")},setToTokenAmount(o){e.toTokenAmount=o?c.toFixed(o,O):""},async setTokenPrice(o,n){let t=e.tokensPriceMap[o]||0;t||(e.loadingPrices=!0,t=await s.getAddressPrice(o)),n==="sourceToken"?e.sourceTokenPriceInUSD=t:n==="toToken"&&(e.toTokenPriceInUSD=t),e.loadingPrices&&(e.loadingPrices=!1),s.getParams().availableToSwap&&s.swapTokens()},switchTokens(){if(e.initializing||!e.initialized)return;const o=e.toToken?{...e.toToken}:void 0,n=e.sourceToken?{...e.sourceToken}:void 0,t=o&&e.toTokenAmount===""?"1":e.toTokenAmount;s.setSourceToken(o),s.setToToken(n),s.setSourceTokenAmount(t),s.setToTokenAmount(""),s.swapTokens()},resetState(){e.myTokensWithBalance=d.myTokensWithBalance,e.tokensPriceMap=d.tokensPriceMap,e.initialized=d.initialized,e.initializing=d.initializing,e.sourceToken=d.sourceToken,e.sourceTokenAmount=d.sourceTokenAmount,e.sourceTokenPriceInUSD=d.sourceTokenPriceInUSD,e.toToken=d.toToken,e.toTokenAmount=d.toTokenAmount,e.toTokenPriceInUSD=d.toTokenPriceInUSD,e.networkPrice=d.networkPrice,e.networkTokenSymbol=d.networkTokenSymbol,e.networkBalanceInUSD=d.networkBalanceInUSD,e.inputError=d.inputError},resetValues(){const{networkAddress:o}=s.getParams(),n=e.tokens?.find(t=>t.address===o);s.setSourceToken(n),s.setToToken(void 0)},getApprovalLoadingState(){return e.loadingApprovalTransaction},clearError(){e.transactionError=void 0},async initializeState(){if(!e.initializing){if(e.initializing=!0,!e.initialized)try{await s.fetchTokens(),e.initialized=!0}catch{e.initialized=!1,T.showError("Failed to initialize swap"),k.goBack()}e.initializing=!1}},async fetchTokens(){const{networkAddress:o}=s.getParams();await s.getNetworkTokenPrice(),await s.getMyTokensWithBalance();const n=e.myTokensWithBalance?.find(t=>t.address===o);n&&(e.networkTokenSymbol=n.symbol,s.setSourceToken(n),s.setSourceTokenAmount("0"))},async getTokenList(){const o=m.state.activeCaipNetwork?.caipNetworkId;if(!(e.caipNetworkId===o&&e.tokens))try{e.tokensLoading=!0;const n=await w.getTokenList(o);e.tokens=n,e.caipNetworkId=o,e.popularTokens=n.sort((t,r)=>t.symbol<r.symbol?-1:t.symbol>r.symbol?1:0),e.suggestedTokens=n.filter(t=>!!U.SWAP_SUGGESTED_TOKENS.includes(t.symbol))}catch{e.tokens=[],e.popularTokens=[],e.suggestedTokens=[]}finally{e.tokensLoading=!1}},async getAddressPrice(o){const n=e.tokensPriceMap[o];if(n)return n;const r=(await A.fetchTokenPrice({addresses:[o]}))?.fungibles||[],a=[...e.tokens||[],...e.myTokensWithBalance||[]]?.find(f=>f.address===o)?.symbol,u=r.find(f=>f.symbol.toLowerCase()===a?.toLowerCase())?.price||0,l=parseFloat(u.toString());return e.tokensPriceMap[o]=l,l},async getNetworkTokenPrice(){const{networkAddress:o}=s.getParams(),t=(await A.fetchTokenPrice({addresses:[o]}).catch(()=>(T.showError("Failed to fetch network token price"),{fungibles:[]}))).fungibles?.[0],r=t?.price.toString()||"0";e.tokensPriceMap[o]=parseFloat(r),e.networkTokenSymbol=t?.symbol||"",e.networkPrice=r},async getMyTokensWithBalance(o){const n=await L.getMyTokensWithBalance(o),t=w.mapBalancesToSwapTokens(n);t&&(await s.getInitialGasPrice(),s.setBalances(t))},setBalances(o){const{networkAddress:n}=s.getParams(),t=m.state.activeCaipNetwork;if(!t)return;const r=o.find(i=>i.address===n);o.forEach(i=>{e.tokensPriceMap[i.address]=i.price||0}),e.myTokensWithBalance=o.filter(i=>i.address.startsWith(t.caipNetworkId)),e.networkBalanceInUSD=r?c.multiply(r.quantity.numeric,r.price).toString():"0"},async getInitialGasPrice(){const o=await w.fetchGasPrice();if(!o)return{gasPrice:null,gasPriceInUSD:null};switch(m.state?.activeCaipNetwork?.chainNamespace){case p.CHAIN.SOLANA:return e.gasFee=o.standard??"0",e.gasPriceInUSD=c.multiply(o.standard,e.networkPrice).div(1e9).toNumber(),{gasPrice:BigInt(e.gasFee),gasPriceInUSD:Number(e.gasPriceInUSD)};case p.CHAIN.EVM:default:const n=o.standard??"0",t=BigInt(n),r=BigInt(E),i=g.getGasPriceInUSD(e.networkPrice,r,t);return e.gasFee=n,e.gasPriceInUSD=i,{gasPrice:t,gasPriceInUSD:i}}},async swapTokens(){const o=M.state.address,n=e.sourceToken,t=e.toToken,r=c.bigNumber(e.sourceTokenAmount).gt(0);if(r||s.setToTokenAmount(""),!t||!n||e.loadingPrices||!r)return;e.loadingQuote=!0;const i=c.bigNumber(e.sourceTokenAmount).times(10**n.decimals).round(0);try{const a=await A.fetchSwapQuote({userAddress:o,from:n.address,to:t.address,gasPrice:e.gasFee,amount:i.toString()});e.loadingQuote=!1;const u=a?.quotes?.[0]?.toAmount;if(!u){F.open({displayMessage:"Incorrect amount",debugMessage:"Please enter a valid amount"},"error");return}const l=c.bigNumber(u).div(10**t.decimals).toString();s.setToTokenAmount(l),s.hasInsufficientToken(e.sourceTokenAmount,n.address)?e.inputError="Insufficient balance":(e.inputError=void 0,s.setTransactionDetails())}catch{e.loadingQuote=!1,e.inputError="Insufficient balance"}},async getTransaction(){const{fromCaipAddress:o,availableToSwap:n}=s.getParams(),t=e.sourceToken,r=e.toToken;if(!(!o||!n||!t||!r||e.loadingQuote))try{e.loadingBuildTransaction=!0;const i=await w.fetchSwapAllowance({userAddress:o,tokenAddress:t.address,sourceTokenAmount:e.sourceTokenAmount,sourceTokenDecimals:t.decimals});let a;return i?a=await s.createSwapTransaction():a=await s.createAllowanceTransaction(),e.loadingBuildTransaction=!1,e.fetchError=!1,a}catch{k.goBack(),T.showError("Failed to check allowance"),e.loadingBuildTransaction=!1,e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}},async createAllowanceTransaction(){const{fromCaipAddress:o,sourceTokenAddress:n,toTokenAddress:t}=s.getParams();if(!(!o||!t)){if(!n)throw new Error("createAllowanceTransaction - No source token address found.");try{const r=await A.generateApproveCalldata({from:n,to:t,userAddress:o}),i=h.getPlainAddress(r.tx.from);if(!i)throw new Error("SwapController:createAllowanceTransaction - address is required");const a={data:r.tx.data,to:i,gasPrice:BigInt(r.tx.eip155.gasPrice),value:BigInt(r.tx.value),toAmount:e.toTokenAmount};return e.swapTransaction=void 0,e.approvalTransaction={data:a.data,to:a.to,gasPrice:a.gasPrice,value:a.value,toAmount:a.toAmount},{data:a.data,to:a.to,gasPrice:a.gasPrice,value:a.value,toAmount:a.toAmount}}catch{k.goBack(),T.showError("Failed to create approval transaction"),e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}}},async createSwapTransaction(){const{networkAddress:o,fromCaipAddress:n,sourceTokenAmount:t}=s.getParams(),r=e.sourceToken,i=e.toToken;if(!n||!t||!r||!i)return;const a=P.parseUnits(t,r.decimals)?.toString();try{const u=await A.generateSwapCalldata({userAddress:n,from:r.address,to:i.address,amount:a,disableEstimate:!0}),l=r.address===o,f=BigInt(u.tx.eip155.gas),C=BigInt(u.tx.eip155.gasPrice),v=h.getPlainAddress(u.tx.to);if(!v)throw new Error("SwapController:createSwapTransaction - address is required");const N={data:u.tx.data,to:v,gas:f,gasPrice:C,value:BigInt(l?a??"0":"0"),toAmount:e.toTokenAmount};return e.gasPriceInUSD=g.getGasPriceInUSD(e.networkPrice,f,C),e.approvalTransaction=void 0,e.swapTransaction=N,N}catch{k.goBack(),T.showError("Failed to create transaction"),e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}},onEmbeddedWalletApprovalSuccess(){T.showLoading("Approve limit increase in your wallet"),k.replace("SwapPreview")},async sendTransactionForApproval(o){const{fromAddress:n,isAuthConnector:t}=s.getParams();e.loadingApprovalTransaction=!0,t?k.pushTransactionStack({onSuccess:s.onEmbeddedWalletApprovalSuccess}):T.showLoading("Approve limit increase in your wallet");try{await P.sendTransaction({address:n,to:o.to,data:o.data,value:o.value,chainNamespace:p.CHAIN.EVM}),await s.swapTokens(),await s.getTransaction(),e.approvalTransaction=void 0,e.loadingApprovalTransaction=!1}catch(i){const a=i;e.transactionError=a?.displayMessage,e.loadingApprovalTransaction=!1,T.showError(a?.displayMessage||"Transaction error"),I.sendEvent({type:"track",event:"SWAP_APPROVAL_ERROR",properties:{message:a?.displayMessage||a?.message||"Unknown",network:m.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:s.state.sourceToken?.symbol||"",swapToToken:s.state.toToken?.symbol||"",swapFromAmount:s.state.sourceTokenAmount||"",swapToAmount:s.state.toTokenAmount||"",isSmartAccount:y(p.CHAIN.EVM)===b.ACCOUNT_TYPES.SMART_ACCOUNT}})}},async sendTransactionForSwap(o){if(!o)return;const{fromAddress:n,toTokenAmount:t,isAuthConnector:r}=s.getParams();e.loadingTransaction=!0;const i=`Swapping ${e.sourceToken?.symbol} to ${c.formatNumberToLocalString(t,3)} ${e.toToken?.symbol}`,a=`Swapped ${e.sourceToken?.symbol} to ${c.formatNumberToLocalString(t,3)} ${e.toToken?.symbol}`;r?k.pushTransactionStack({onSuccess(){k.replace("Account"),T.showLoading(i),S.resetState()}}):T.showLoading("Confirm transaction in your wallet");try{const u=[e.sourceToken?.address,e.toToken?.address].join(","),l=await P.sendTransaction({address:n,to:o.to,data:o.data,value:o.value,chainNamespace:p.CHAIN.EVM});return e.loadingTransaction=!1,T.showSuccess(a),I.sendEvent({type:"track",event:"SWAP_SUCCESS",properties:{network:m.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:s.state.sourceToken?.symbol||"",swapToToken:s.state.toToken?.symbol||"",swapFromAmount:s.state.sourceTokenAmount||"",swapToAmount:s.state.toTokenAmount||"",isSmartAccount:y(p.CHAIN.EVM)===b.ACCOUNT_TYPES.SMART_ACCOUNT}}),S.resetState(),r||k.replace("Account"),S.getMyTokensWithBalance(u),l}catch(u){const l=u;e.transactionError=l?.displayMessage,e.loadingTransaction=!1,T.showError(l?.displayMessage||"Transaction error"),I.sendEvent({type:"track",event:"SWAP_ERROR",properties:{message:l?.displayMessage||l?.message||"Unknown",network:m.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:s.state.sourceToken?.symbol||"",swapToToken:s.state.toToken?.symbol||"",swapFromAmount:s.state.sourceTokenAmount||"",swapToAmount:s.state.toTokenAmount||"",isSmartAccount:y(p.CHAIN.EVM)===b.ACCOUNT_TYPES.SMART_ACCOUNT}});return}},hasInsufficientToken(o,n){return g.isInsufficientSourceTokenForSwap(o,n,e.myTokensWithBalance)},setTransactionDetails(){const{toTokenAddress:o,toTokenDecimals:n}=s.getParams();!o||!n||(e.gasPriceInUSD=g.getGasPriceInUSD(e.networkPrice,BigInt(e.gasFee),BigInt(E)),e.priceImpact=g.getPriceImpact({sourceTokenAmount:e.sourceTokenAmount,sourceTokenPriceInUSD:e.sourceTokenPriceInUSD,toTokenPriceInUSD:e.toTokenPriceInUSD,toTokenAmount:e.toTokenAmount}),e.maxSlippage=g.getMaxSlippage(e.slippage,e.toTokenAmount),e.providerFee=g.getProviderFee(e.sourceTokenAmount))}},s=D(S);export{s as S};
